package com.amazon.spapi.sequencing.crypto;

import com.google.common.base.Preconditions;

import javax.annotation.Nonnull;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.InvalidKeyException;
import java.security.SignatureException;


/**
 * An Asymmetric verison of {@link CryptoProvider} that uses RSA.
 * Encryption is performed using RSA with PKCS1Padding.
 * Signing is performed using SHA256withRSA.
 */
public class AsymmetricCryptoProvider implements CryptoProvider {
    private static final String REQUIRED_KEY_ALGORITHM = "RSA";
    private static final String SIGNATURE_ALGORITHM = "SHA256withRSA";
    private static final String ENCRYPTION_ALGORITHM = "RSA/ECB/OAEPWithSHA-256AndMGF1Padding";

    /**
     * {@inheritDoc}
     */
    @Nonnull
    @Override
    public byte[] encrypt(@Nonnull byte[] plainText, @Nonnull EncryptionMaterials materials)
            throws EncryptionException {
        Preconditions.checkArgument(plainText != null, "plainText must be non-null.");

        Cipher cipher = getInitializedCipher(Cipher.ENCRYPT_MODE, materials);
        return applyCipher(cipher, plainText);
    }

    /**
     * {@inheritDoc}
     */
    @Nonnull
    @Override
    public byte[] decrypt(@Nonnull byte[] cipherText, @Nonnull EncryptionMaterials materials)
            throws EncryptionException {
        Preconditions.checkArgument(cipherText != null, "cipherText must be non-null.");

        Cipher cipher = getInitializedCipher(Cipher.DECRYPT_MODE, materials);
        return applyCipher(cipher, cipherText);
    }

    /**
     * {@inheritDoc}
     */
    @Nonnull
    @Override
    public byte[] sign(@Nonnull byte[] bytesToSign, @Nonnull EncryptionMaterials materials)
            throws SignatureGenerationException {
        Preconditions.checkArgument(bytesToSign != null, "bytesToSign must be non-null.");

        PrivateKey key = validatePrivateKey(materials);

        byte[] signatureBytes;
        try {
            Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);
            signature.initSign(key, new SecureRandom());
            signature.update(bytesToSign);
            signatureBytes = signature.sign();
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(String.format("NoSuchAlgorithmException for %s", SIGNATURE_ALGORITHM), e);
        } catch (InvalidKeyException e) {
            throw new SignatureGenerationException(e);
        } catch (SignatureException e) {
            throw new SignatureGenerationException(e);
        }

        return signatureBytes;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void validateSignature(@Nonnull byte[] signatureBytes, @Nonnull byte[] bytesToSign,
                                  @Nonnull EncryptionMaterials materials) throws SignatureGenerationException,
            SignatureValidationException {
        Preconditions.checkArgument(signatureBytes != null, "signatureBytes must be non-null.");
        Preconditions.checkArgument(bytesToSign != null, "bytesToSign must be non-null.");

        PublicKey key = validatePublicKey(materials);

        try {
            Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);
            signature.initVerify(key);
            signature.update(bytesToSign);
            if (!signature.verify(signatureBytes)) {
                throw new SignatureValidationException("Signature mismatch.  Possible tampering attempt.");
            }
        } catch (InvalidKeyException e) {
            throw new SignatureGenerationException(e);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(String.format("NoSuchAlgorithmException for %s", SIGNATURE_ALGORITHM), e);
        } catch (SignatureException e) {
            throw new SignatureGenerationException(e);
        }
    }

    /**
     * Helper function to apply a cipher to some data and return the results.  Performs exception mapping.
     * @param cipher the Cipher to apply.
     * @param text the text to apply the cipher to
     * @return the text generated by applying the cipher to the input text
     * @throws EncryptionException if there is a problem applying the cipher.
     */
    @Nonnull
    private byte[] applyCipher(@Nonnull Cipher cipher, @Nonnull byte[] text) throws EncryptionException {
        try {
            return cipher.doFinal(text);
        } catch (IllegalBlockSizeException e) {
            throw new EncryptionException(e);
        } catch (BadPaddingException e) {
            throw new EncryptionException(e);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Nonnull
    public Cipher getInitializedCipher(int mode, @Nonnull EncryptionMaterials materials) throws EncryptionException {

        Key key;
        if  (Cipher.DECRYPT_MODE == mode) {
            key = validatePrivateKey(materials);
        } else {
            key = validatePublicKey(materials);
        }

        Cipher cipher;
        try {
            cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);
            cipher.init(mode, key, new SecureRandom());
        } catch (InvalidKeyException e) {
            throw new EncryptionException(e);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(String.format("NoSuchAlgorithmException for %s", SIGNATURE_ALGORITHM), e);
        } catch (NoSuchPaddingException e) {
            throw new IllegalStateException(String.format("NoSuchPaddingException for %s", SIGNATURE_ALGORITHM), e);
        }

        return cipher;
    }

    /**
     * Helper function to ensure EncryptionMaterials are valid and the Key matches a specific class.
     * @param materials the Materials to validate
     * @param clazz the expected class of the key.
     * @param message The error message if the key is not of the expected class
     * @return the key.
     */
    @Nonnull
    private Key validateKey(@Nonnull EncryptionMaterials materials, @Nonnull Class<? extends Key> clazz,
                            @Nonnull String message) {
        Preconditions.checkArgument(materials != null, "Materials must be non-null.");
        Preconditions.checkArgument(REQUIRED_KEY_ALGORITHM.equals(materials.getKey().getAlgorithm()),
                                    "AsymmetricCryptoProvider requires an RSA key.");
        Preconditions.checkArgument(clazz.isAssignableFrom(materials.getKey().getClass()), message);

        return materials.getKey();
    }

    /**
     * Helper function that validates that the EncryptionMaterials contain a valid PrivateKey.
     * @param materials the materials to validate
     * @return the PrivateKey
     */
    @Nonnull
    private PrivateKey validatePrivateKey(@Nonnull EncryptionMaterials materials) {
        return (PrivateKey) validateKey(materials, PrivateKey.class, "Key must be of type PrivateKey.");
    }

    /**
     * Helper function that validates that the EncryptionMaterials contain a valid PublicKey.
     * @param materials the materials to validate
     * @return the PublicKey
     */
    @Nonnull
    private PublicKey validatePublicKey(@Nonnull EncryptionMaterials materials) {
        return (PublicKey) validateKey(materials, PublicKey.class, "Key must be of type PublicKey.");
    }
}
