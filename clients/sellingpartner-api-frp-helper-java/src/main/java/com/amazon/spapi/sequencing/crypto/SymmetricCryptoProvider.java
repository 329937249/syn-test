package com.amazon.spapi.sequencing.crypto;

import com.google.common.base.Preconditions;
import lombok.extern.apachecommons.CommonsLog;

import javax.annotation.Nonnull;
import javax.crypto.Mac;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import java.security.InvalidAlgorithmParameterException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.InvalidKeyException;
import java.util.Arrays;
/**
 * A Symmetric verison of {@link CryptoProvider} that uses AES and HmacSha256.
 * Encryption is performed using AES/CBC/PKCS5Padding
 * HMAC is performed using HmacSha256.
 */
@CommonsLog
public class SymmetricCryptoProvider implements CryptoProvider {
    private static final String REQUIRED_KEY_ALGORITHM = "AES";
    private static final String ENCRYPTION_ALGORITHM = "AES/CBC/PKCS5Padding";
    private static final String MAC_ALGORITHM = "HmacSha256";

    /**
     * {@inheritDoc}
     */
    @Nonnull
    @Override
    public byte[] encrypt(@Nonnull byte[] plainText, @Nonnull EncryptionMaterials materials)
            throws EncryptionException {
        Preconditions.checkArgument(plainText != null, "plainText must be non-null.");

        Cipher cipher = getInitializedCipher(Cipher.ENCRYPT_MODE, materials);

        return applyCipher(cipher, plainText);
    }

    /**
     * {@inheritDoc}
     */
    @Nonnull
    @Override
    public byte[] decrypt(@Nonnull byte[] cipherText, @Nonnull EncryptionMaterials materials)
            throws EncryptionException {
        Preconditions.checkArgument(cipherText != null, "cipherText must be non-null.");

        Cipher cipher = getInitializedCipher(Cipher.DECRYPT_MODE, materials);

        return applyCipher(cipher, cipherText);
    }

    /**
     * {@inheritDoc}
     */
    @Nonnull
    @Override
    public byte[] sign(@Nonnull byte[] bytesToSign, @Nonnull EncryptionMaterials materials)
            throws SignatureGenerationException {
        Preconditions.checkArgument(bytesToSign != null, "bytesToSign must be non-null..");
        validateMaterials(materials, false);

        Mac mac;
        try {
            mac = Mac.getInstance(MAC_ALGORITHM);
            mac.init(materials.getKey());
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(String.format("NoSuchAlgorithmException for %s", MAC_ALGORITHM), e);
        } catch (InvalidKeyException e) {
            throw new SignatureGenerationException(e);
        }

        return mac.doFinal(bytesToSign);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void validateSignature(@Nonnull byte[] signature, @Nonnull byte[] bytesToSign,
                                  @Nonnull EncryptionMaterials materials) throws SignatureValidationException, SignatureGenerationException {
        Preconditions.checkArgument(signature != null, "signature must be non-null.");
        Preconditions.checkArgument(bytesToSign != null, "bytesToSign must be non-null.");
        validateMaterials(materials, false);

        byte[] expectedSignature = sign(bytesToSign, materials);

        if (!MessageDigest.isEqual(signature, expectedSignature)) {
            if (log.isTraceEnabled()) {
               log.trace(String.format("Signature mismatch detected.  Expected=%s, Actual=%s",
                       Arrays.toString(expectedSignature), Arrays.toString(signature)));
            }
            throw new SignatureValidationException("Signature mismatch.  Possible tampering attempt.");
        }
    }

    /**
     * Helper function to apply a cipher to some data and return the results.  Performs exception mapping.
     * @param cipher the Cipher to apply.
     * @param text the text to apply the cipher to
     * @return the text generated by applying the cipher to the input text
     * @throws EncryptionException if there is a problem applying the cipher.
     */
    @Nonnull
    private byte[] applyCipher(@Nonnull Cipher cipher, @Nonnull byte[] text) throws EncryptionException {
        try {
            return cipher.doFinal(text);
        } catch (IllegalBlockSizeException e) {
            throw new EncryptionException(e);
        } catch (BadPaddingException e) {
            throw new EncryptionException(e);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Nonnull
    public Cipher getInitializedCipher(int mode, @Nonnull EncryptionMaterials materials) throws EncryptionException {
        validateMaterials(materials, true);

        Cipher cipher;
        try {
            cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);
            cipher.init(mode, materials.getKey(),
                    new IvParameterSpec(materials.getInitializationVector()), new SecureRandom());
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(String.format("NoSuchAlgorithmException for %s", ENCRYPTION_ALGORITHM), e);
        } catch (NoSuchPaddingException e) {
            throw new IllegalStateException(String.format("NoSuchPaddingException for %s", ENCRYPTION_ALGORITHM), e);
        } catch (InvalidKeyException e) {
            throw new EncryptionException(e);
        } catch (InvalidAlgorithmParameterException e) {
            throw new EncryptionException(e);
        }

        return cipher;
    }

    /**
     * Helper function to ensure EncryptionMaterials are valid.
     * @param materials the Materials to validate
     * @param ivRequired whether or not this function should treat the InitializationVector as required.
     * The IV is required for encryption/decryption but not for HMAC operations.
     */
    private void validateMaterials(@Nonnull EncryptionMaterials materials, boolean ivRequired) {
        Preconditions.checkArgument(materials != null, "Materials must be non-null.");
        Preconditions.checkArgument(REQUIRED_KEY_ALGORITHM.equals(materials.getKey().getAlgorithm()),
                                    "SymmetricCryptoProvider requires an AES Key.");
        Preconditions.checkArgument(!ivRequired || materials.getInitializationVector() != null, "IV must be non-null.");
    }

}
